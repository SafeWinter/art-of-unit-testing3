# 第 2 章 第一个单元测试 A first unit test



> **本章概要**
>
> - 用 `Jest` 编写第一个单元测试
> - 测试结构与命名约定
> - 使用断言库（assertion library）
> - 重构测试代码并减少代码冗余

本章介绍 `Jest` 的基本用法，为后续单元测试代码的演示做铺垫。



## 2.1 Jest 简介 Introducing Jest

`Jest` 是由 `Facebook` 受测试框架 `Jasmine` 启发而创建的开源测试框架，最初用于前端 `React` 组件的测试。

`Jest` 支持两种测试语法（flavors）：

1. 使用 `test` 原语；
2. 基于 `Jasmine` 语法风格（`describe`、`it` 等）；



### 2.1.1 环境搭建 Preparing our environment

基本要求：

- `npm` 版本在 `v6.10.2` 以上即可。
- 安装 `Git`



### 2.1.2 创建工作目录 Preparing our working folder

搭建命令：

```bash
mkdir ch2
cd ch2
npm init --yes # 或者：yarn init -yes
git init
```

`Jest` 的配置可在其配置文件 `jest.config.js` 中进行，也可在 `node` 项目的配置文件 `package.json` 中进行。



### 2.1.3 安装 Jest（Installing Jest）

安装命令：（项目层面）

```bash
npm install --save-dev jest # 或者：yarn add jest -dev
```

也可以全局安装（不推荐）：（系统层面）

```bash
npm install -g jest
```

实际项目中一般通过 `npm` 命令运行测试，很少使用全局 `jest` 命令。



### 2.1.4 创建测试文件 Creating a test file

`Jest` 查找项目测试文件的默认方式：

1. 若存在 `__tests__` 文件夹，默认将其中所有文件视为测试文件，无视命名规则；
2. 递归查找项目根路径下所有以 `*.spec.js` 或 `*.test.js` 结尾的文件；
3. 在手动配置的路径下查找（详见 `Jest` 官方 [配置文档](https://jestjs.io/docs/configuration)）。

注意：命名时推荐使用 `*.spec.js`；`*.test.js` 可视为 `*.spec.js` 的简化形式。

> **测试文件的存放位置**
>
> 有两种观点：
>
> - 和待测文件放在一起；
> - 单独放在一个测试文件夹中（推荐）。
>
> 具体怎么放没有硬性规定，只是第二种更方便存放其他与测试相关的辅助文件，同时 `Jest` 还支持原文件和测试文件的导航映射。

创建第一个测试文件：

```bash
# 进入项目根目录 (Powershell 环境)
> pwd 
Path
----
C:\Users\ad\Desktop\ch2
# 添加 git 忽略文件
> echo .gitignore > .gitignore; echo node_modules >> .gitignore
# 创建测试文件夹 __tests__
> mkdir __tests__ | Out-Null
# 新建单元测试
> New-Item -Name hellojest.test.js -Path __tests__ | Out-Null
# 编辑测试内容
> Get-Content __tests__/hellojest.test.js
test('hello jest', () => {
  expect('hello').toEqual('goodbye');
});
```



### 2.1.5 运行 Jest 测试 Executing Jest

修改 `package.json` 默认的 `test` 命令脚本，改为 `"jest"`（第 9 行）：

```bash
# 修改 test 脚本
> Get-Content package.json
{
  "name": "ch2",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "test": "jest"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  }
}
```

执行命令 `yarn test`：

```bash
# 运行测试
> yarn test
yarn run v1.22.10
$ jest
 FAIL  __tests__/hellojest.test.js
  × hello jest (5 ms)

  ● hello jest

    expect(received).toEqual(expected) // deep equality

    Expected: "goodbye"
    Received: "hello"

      1 | test('hello jest', () => {
    > 2 |   expect('hello').toEqual('goodbye');
        |                   ^
      3 | });
      4 |

      at Object.toEqual (__tests__/hellojest.test.js:2:19)

Test Suites: 1 failed, 1 total
Tests:       1 failed, 1 total
Snapshots:   0 total
Time:        0.353 s
Ran all test suites.
error Command failed with exit code 1.
info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command.
$ 
```

实测截图：

![](assets/2.1.png)

**图 2.1 执行首个 Jest 测试的运行结果截图**

修改 `hellojest.test.js`：

```bash
> vim __tests__/hellojest.test.js
> gc __tests__/hellojest.test.js
test('hello jest', () => {
  expect('goodbye').toEqual('goodbye');
});
```

再次运行 `yarn test`：

![](assets/2.2.png)

**图 2.2 修改后的测试结果截图（已通过测试）**

此外，还可以启用 `Jest` 监听模式 `jest --watch`，实现边修改边测试（第 11 行）：

```bash
# 添加 Jest 监听模式命令 testw
> vim package.json
> gc package.json
{
  "name": "ch2",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "test": "jest",
    "testw": "jest --watch"
  },
  "devDependencies": {
    "jest": "^29.7.0"
  }
}
```

执行 `yarn run testw` 实测效果：

![](assets/2.3.png)

**图 2.3 启用 Jest 监听模式，实现文件编辑过程中实时运行测试**



## 2.2 测试库、断言库、运行工具、报表工具 The library, the assert, the runner, and the reporter

`Jest` 在测试中充当的角色：

1. 测试工具库（*test library*）
2. 断言库（*assertion library*）：即 `expect` 语句的使用；
3. 测试运行工具（*test runner*）
4. 测试报表工具（*test reporter*）



## 2.3 单元测试框架的作用

主要作用有：

1. 统一的结构化设计（*structure*）：因为开源，不用重复造轮子，人人都能上手
2. 可复用性强（repeatability）：复用性贯穿测试的全流程：编写、执行、报错、结果报告……
3. 可信度高且省时（*Confidence and time savings*）：自己手写的框架不太可靠，出错几率大，分散注意力。
4. 增进共同理解（*Shared understanding*）：（团队场景）通过测试，则表明任务完成

![](assets/2.4.png)

**图 2.4 借助单元测试框架，单元测试写成代码后，可通过 IDE 内的测试运行工具或命令行运行，开发人员或自动构建流程则可以通过测试报告工具（导出文本或 IDE 控制台打印）查看测试结果**

![](assets/2.5.png)

**图 5 测试框架的作用：帮助开发人员编写和执行测试并审查结果**

翻译过来就是：

**表 2.1：测试框架在测试的编写、测试、审查阶段为开发者提供的具体帮助**

|   单元测试实践   | 框架提供的帮助                                               |
| :--------------: | :----------------------------------------------------------- |
| **编写测试用例** | 为开发者提供辅助函数（helper functions）、断言功能、以及 **结构化设计的** 功能函数。 |
|   **运行测试**   | 框架提供运行工具（通常为命令行），可以——<br/>1. 识别代码中的测试用例；<br/>2. 自动运行测试；<br/>3. 在运行时显示测试状态。 |
| **查看测试结果** | 内置的测试运行工具通常会提供以下信息——<br/>1. 有多少测试运行了；<br/>2. 有多少测试没有运行；<br/>3. 有多少测试运行失败；<br/>4. 具体哪些测试失败了；<br/>5. 测试失败的原因；<br/>6. 测试失败的代码位置；<br/>7. 给出可能导致测试失败的任何异常的完整堆栈跟踪信息，以便查看调用堆栈内的相关方法调用情况。 |



> [!warning]
>
> **注意**
>
> 使用单元测试框架，**并不能确保** 编写的测试具有可读性、可维护性或可信性，**也不能确保** 它们涵盖了想测试的所有逻辑！！！
